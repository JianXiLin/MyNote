# Observer观察者模式

## 一、作用

可用于实现监听（观察）对个某个状态的改变或者动作的发生，并以此进行相应的动作。可在不修改原先代码的前提下，进行监听对象的扩展。

<b type="h">适用场景：</b>

1. 一个状态改变需要改变其它对象，且对象对状态的发生是未知的。
2. 多个对象需要监听某个动作的发生或状态改变

## 二、实现

&emsp;&emsp;将观察者对象添加到被观察者中，由被观察者在状态改变时，调用观察者的执行动作。
&emsp;&emsp;观察者模式也是一种发布-订阅，被观察者可看着是消息的发布者，观察者则可当做消息的订阅者。订阅者信息添加到发布者中去，由发布者在某个时刻向订阅者发送信息或执行动作。

### 1. 同步阻塞

被观察者执行多个观察者的动作的过程是一个同步阻塞的操作。
单线程内即可完成，但被观察者会被阻塞，需等待观察者执行完毕才可进行后续操作。
<!-- 
```puml
    skinparam backgroundColor Beige
     
    Interface Observer{
        void do()
    }
    note right : 观察者接口

    class AObserver{
        void do()
    }
    note top : A观察者类

    class BObserver{
        void do()
    }
    note top : B观察者类

    class CObserver{
        void do()
    }
    note top : C观察者类

    AObserver ..|> Observer
    BObserver ..|> Observer
    CObserver ..|> Observer

    class Subject{
        Observer[] observers；
        void statusChanged(){}
    }
    note right : 被观察者类

    note left of Subject
        void statusChanged(){
            // 状态改变、事件触发，
            // 执行观察者的动作。
            for (observer : observers){
                observer.do()
            }
        }
    end note
    

    class main{
        Subject subject
    }
    main -- Subject
    Observer --o Subject
```  -->
![观察者模式/20210515230514](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/观察者模式/20210515230514.png?x-oss-process=image/resize,p_100/sharpen,50)

### 2. 异步非阻塞

&emsp;&emsp;若要实现异步非阻塞，可通过以下方式实现：

- 方式一: 可在被观察者执行观察者的动作时，对其开一个独立的线程去执行。(`线程开销大`)
- 方式二： 可在被观察者执行观察者的动作时，使用线程池（Executor）去执行。

<!-- 
```puml
    skinparam backgroundColor Beige
     
    Interface Observer{
        void do()
    }
    note right : 观察者接口

    class AObserver{
        void do()
    }
    note top : A观察者类

    class BObserver{
        void do()
    }
    note top : B观察者类

    class CObserver{
        void do()
    }
    note top : C观察者类

    AObserver ..|> Observer
    BObserver ..|> Observer
    CObserver ..|> Observer

    class Subject{
        Observer[] observers；
        void statusChanged(){}
    }
    note right : 被观察者类

    note left of Subject
        void statusChanged(){
            // 状态改变、事件触发，
            // 执行观察者的动作。
            for (observer : observers){
                <b><color:[[cf1322]]>// 为每个观察者开一个新的线程 </b>
                 new Thread() {observer.do()} 
            }
        }
    end note
    

    class main{
        Subject subject
    }
    main -- Subject
    Observer --o Subject
```  -->

![观察者模式/20210515230607](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/观察者模式/20210515230607.png?x-oss-process=image/resize,p_100/sharpen,50)
<!-- 
```puml
    skinparam backgroundColor Beige
     
    Interface Observer{
        void do()
    }
    note right : 观察者接口

    class AObserver{
        void do()
    }
    note top : A观察者类

    class BObserver{
        void do()
    }
    note top : B观察者类

    class CObserver{
        void do()
    }
    note top : C观察者类

    AObserver ..|> Observer
    BObserver ..|> Observer
    CObserver ..|> Observer

    class Subject{
        Observer[] observers；
        <b><color:[[cf1322]]> Executor executor;</b>
        void statusChanged(){}
    }
    note right : 被观察者类

    note left of Subject
        void statusChanged(){
            // 状态改变、事件触发，
            // 执行观察者的动作。
            for (observer : observers){
                <b><color:[[cf1322]]>// 通过线程池来执行观察者的动作 </b>
                 executor.execute(..observer.do()) 
            }
        }
    end note
    

    class main{
        Subject subject
    }
    main -- Subject
    Observer --o Subject
```  -->

![观察者模式/20210515230735](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/观察者模式/20210515230735.png?x-oss-process=image/resize,p_100/sharpen,50)

### 3. 非进程（消息队列）

&emsp;&emsp;当观察者位于另外一个独立系统且该系统无提供对应的RPC接口，则可以借助`消息队列`来实现对观察者的通知，执行观察者的对应动作。
&emsp;&emsp;通过借助第三方系统`消息队列`来作为观察者与被观察者间的通讯的处理方式，不同于观察者添加到被观察者中的这种方式，前者可更好地实现观察者与被观察者间的解耦合。

### 4. 同步与异步两种方式切换（EventBus）

实现这同步与异步方式的切换：

- 方式一：在被观察者类中实现同步和异步的切换（`切换功能的代码复用性差`）
- 方式二: 借助EventBus来实现

EventBus使用方式
<!-- 
```puml
    skinparam backgroundColor Beige
     
    class AObserver{
        void do(Object 消息)
    }
    note top : A观察者类

    class BObserver{
        void do(Object 消息)
    }
    note top : B观察者类

    class CObserver{
        void do(Object 消息)
    }
    note top : C观察者类

    note left of AObserver
        <b><color:[[cf1322]]> 注解标记，</b>
        <b><color:[[cf1322]]> 用于接受被观察者的消息</b>
        @Subscribe
        void do(Object 消息){
            // 执行内容
        }
    end note

    AObserver ..|> Subject
    BObserver ..|> Subject
    CObserver ..|> Subject

    class Subject{
        <b><color:[[cf1322]]> // 引入EventBus</b>
        EventBus eventBus;
        void statusChanged(){}
        void addObserver(Object observer)
    }
    note right : 被观察者类

    note left of Subject
        void statusChanged(){
            // 方式一：同步
            eventBus = new EventBus();
            // 方式二：异步
            eventBus = new AsyncEventBus(~);
            // 发送消息
            eventBus.post(消息);
        }
        void addObserver(Object observer){
            eventBus.register(observer);
        }
    end note
    

    class main{
        Subject subject
    }
    main -- Subject

```  -->

![观察者模式/20210515230849](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/观察者模式/20210515230849.png?x-oss-process=image/resize,p_100/sharpen,50)

#### 指定观察者

&emsp;&emsp;通过EventBus实现的观察者模式，可指定特定的观察者执行动作。

&emsp;&emsp;通过`event.post(message)`中的message参数的类型可指定发送给对应参数类型的观察者方法。
&emsp;&emsp;例如发送MessageA类型的消息，则会通知到`@Subscribe`标记的参数为MessageA的观察者方法。而发送MessageA的子类MessageAC则会发送给MessageA和MessageAC对应参数的方法。

<b type="h"></b>

<!-- ```puml
    skinparam backgroundColor Beige
    class MessageA
    class MessageAC
    Class MessageB

    MessageAC --|> MessageA
``` -->

![观察者模式/20210515231023](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/观察者模式/20210515231023.png?x-oss-process=image/resize,p_100/sharpen,50)

## 三、案例

### 1. 同步阻塞方式

模拟场景：父母、宠物狗作为观察者，观察到孩子哭后，分别做相应的动作。
&emsp;&emsp;对应“孩子哭”这一个动作，我们可以对其进行包装，封装分一个Event事件，方便事件的扩展以及观察者的获取。
&emsp;&emsp;当被观察者Child.wakeUp(),则会依次执行被观察者的相应操作，即调用Observer的actionOnWakeUp()方法，

<!-- ![2020-03-19-16-35-57](./imgs/5.4、Observer观察者.md/2020-03-19-16-35-57.png) -->

![观察者模式/20210515231129](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/观察者模式/20210515231129.png?x-oss-process=image/resize,p_100/sharpen,50)

图中内容：

- Child ： 被观察的对象。

    聚合多个Observer。在被观察的动作( wakeUp() )发生时，依次调用Observer相应的方法。

- Observer ：观察者

- Mum、Dad、Dog ：具体的观察者对象。

- WakeUpEvent : 被观察者中的被观察的事件对象。

    包含事件的相应信息，以及被观察者本身。

- Event ：事件的基类

### 说明

WakeUpEvent 的作用

  1. 使观察者可`获取事件内容`来做不同的处理
  2. T getSource()。使观察者可`获取被观察者本身的内容`，以便根据被观察者做相应的处理。
  使得观察者作用与不同的被观察者（事件源对象）。

Event 的作用
  
   1. 作为WakeUpEvent事件的基类，以形成事件体系
