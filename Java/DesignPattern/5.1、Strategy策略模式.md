# Strategy 策略模式

## 一、作用

可实现同一任务的多种方式拆分陈多个独立的模块，各实现方式间相互独立且可相互替换。
可用于加强实现算法的扩展性、复用性。

## 二、实现


将负责各种实现方式拆分作为独立的策略类，通过一个上下文类来实现对各策略类的引用，上下文类实现、执行任务，而是将执行操作交给策略类实现。

### 1. 无状态策略(可复用的策略)

&emsp;&emsp;当实现算法的内容，无包含上下文参数，实现算法的策略类是无状态的，可共享时，可在先创建好策略类，方便后续使用。

<!-- ```puml
    skinparam backgroundColor Beige
     
    Interface Strategy{
        void execute()
    }
    note right : 策略接口

    class AStrategy{
        void execute()
    }
    note top : A策略类

    class BStrategy{
        void execute()
    }
    note top : B策略类

    class CStrategy{
        void execute()
    }
    note top : C策略类

    AStrategy ..|> Strategy
    BStrategy ..|> Strategy
    CStrategy ..|> Strategy

    class Context{
        void do(){}
    }
    note bottom : 上下文(使用策略类)

    note left of Context
        Map<String,Strategy> strategys;
        static{
            strategys.put(key,new AStrategy());
            ...  
        }
        void do(){
            if (A){
                strategys.get(A).execute()
            }
            super.a();
        }
    end note
    

    class main{
        Context context
    }
    main -- Context
    Context -- Strategy
``` -->

![策略模式/20210515003947](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/策略模式/20210515003947.png?x-oss-process=image/resize,p_100/sharpen,50)

### 2. 带状态的策略

&ensp;&ensp;当策略类是包含上下文参数时，即带有状态，则需在使用时，从相应的工厂获取新的策略对象。

<!-- 
```puml
    skinparam backgroundColor Beige
     
    Interface Strategy{
        void execute()
    }
    note right : 策略接口

    class AStrategy{
        void execute()
    }
    note top : A策略类

    class BStrategy{
        void execute()
    }
    note top : B策略类

    class CStrategy{
        void execute()
    }
    note top : C策略类

    class StrategyFactory{
        Strategy createStrategy(type)
    }
    note left : 策略工厂

    AStrategy ..|> Strategy
    BStrategy ..|> Strategy
    CStrategy ..|> Strategy

    class Context{
        StrategysFactory factory;
        void do(){}
    }
    note bottom : 上下文(使用策略类)

    note left of Context

        void do( type ){
            if (A){
                strategy = factory.createStrategy(A)；
                strategy.execute();
            }
            super.a();
        }
    end note
    
    Context o.. StrategyFactory

    class main{
        Context context
    }
    main -- Context
    Context -- Strategy
``` -->

![策略模式/20210515004051](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/策略模式/20210515004051.png?x-oss-process=image/resize,p_100/sharpen,50)

## 三、案例：排序（Comparator）

方式一： 使用Comparable : 提高排序内容的扩展性
方式二： 使用Comparator :  即提高排序内容的扩展性，又提高排序内容的排序规则`（处理方式、排序策略）`的扩展性

### 1. 未使用策略模式前（Comparable）

以对猫狗等动物对象进行排序的操作为例。每种动物对象都需要可通过大小和颜色来排序。

[![a](https://mermaid.ink/img/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5cdGNsYXNzIG1haW5cblx0bWFpbiAtLSBzb3J0b3Jcblx0Y2xhc3Mgc29ydG9ye1xuXHRcdHNvcnQoQ29tcGFyYWJsZVtdIGMpJCBcblx0fVxuXHRzb3J0b3IgLS0-IENvbXBhcmFibGVcblx0Y2xhc3MgQ29tcGFyYWJsZX5Ufntcblx0XHQ8PGludGVyZmFjZT4-XG5cdFx0Y29tcGFyZVRvKFQgdClpbnRcblx0fVxuXHRjbGFzcyBDYXR7XG5cdFx0LWludCB3ZWlnaHRcblx0XHQtU3RyaW5nIGNvbG9yXG5cdFx0LWNvbXBhcmVUbyhDYXQgYylpbnRcblx0fVxuXHRDYXQgLi58PkNvbXBhcmFibGVcblx0Y2xhc3MgRG9ne1xuXHRcdC1pbnQgd2VpZ2h0XG5cdFx0LVN0cmluZyBjb2xvclxuXHRcdC1jb21wYXJlVG8oRG9nIGQpaW50XG5cdH1cblx0RG9nIC4ufD5Db21wYXJhYmxlXG5cdFxuXHRcblxuXHQiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)](https://mermaid-js.github.io/mermaid-live-editor/[[/edit/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5cdGNsYXNzIG1haW5cblx0bWFpbiAtLSBzb3J0b3Jcblx0Y2xhc3Mgc29ydG9ye1xuXHRcdHNvcnQoQ29tcGFyYWJsZVtdIGMpJCBcblx0fVxuXHRzb3J0b3IgLS0-IENvbXBhcmFibGVcblx0Y2xhc3MgQ29tcGFyYWJsZX5Ufntcblx0XHQ8PGludGVyZmFjZT4-XG5cdFx0Y29tcGFyZVRvKFQgdClpbnRcblx0fVxuXHRjbGFzcyBDYXR7XG5cdFx0LWludCB3ZWlnaHRcblx0XHQtU3RyaW5nIGNvbG9yXG5cdFx0LWNvbXBhcmVUbyhDYXQgYylpbnRcblx0fVxuXHRDYXQgLi58PkNvbXBhcmFibGVcblx0Y2xhc3MgRG9ne1xuXHRcdC1pbnQgd2VpZ2h0XG5cdFx0LVN0cmluZyBjb2xvclxuXHRcdC1jb21wYXJlVG8oRG9nIGQpaW50XG5cdH1cblx0RG9nIC4ufD5Db21wYXJhYmxlXG5cdFxuXHRcblxuXHQiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ]])

​缺点： `扩展性差，违反OCP原则（开闭原则）`

使用Comparable后，排序规则整合在Cat、Dog类中。在添加新的排序规则时，需要修改原有的Cat类。

### 2. 使用策略模式（Comparator）

将各个排序规则作为一个个单独的策略进行拆分。排序策略可单独添加或删除，排序规则扩展性更强。

![策略模式/image-20200312135119252](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/策略模式/image-20200312135119252.png?x-oss-process=image/resize,p_100/sharpen,50)

使用Comparator，排序规则被拆分开来。在添加新排序规则时，只需添加XXXComparator排序器类。
