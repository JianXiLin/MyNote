::: hljs-center

## <font color=#4CAF50 size=6>单例设计模式八种方式</font>

:::

 ### <font color=#4CAF50 size=4>1、 饿汉式(静态常量) </font>
 #### 步骤：
1. 构造器私有化, 外部能new
2. 本类内部创建对象实例
3. 提供一个公有的静态方法，返回实例对象
 #### 代码：
```java
/**	 
 *  饿汉式(静态变量)
 */

class Singleton {
	/**
	 * 1. 构造器私有化, 外部能new
	 */
	private Singleton() {
		
	}

	/**
	 * 2.本类内部创建对象实例
	 */
	private final static Singleton instance = new Singleton();

	/**
	 * 3. 提供一个公有的静态方法，返回实例对象
	 * @return
	 */
	public static Singleton getInstance() {
		return instance;
	}
	
}
```
#### 优缺：
 ### <font color=#4CAF50 size=4>2、 饿汉式（静态代码块）</font>
 #### 步骤：
1. 构造器私有化, 外部能new
2. 本类内部创建对象实例
3. 提供一个公有的静态方法，返回实例对象
 #### 代码：
```java
//饿汉式(静态变量)

class Singleton {
	
	//1. 构造器私有化, 外部能new
	private Singleton() {
		
	}
	

	//2.本类内部创建对象实例
	private  static Singleton instance;
	
	static { // 在静态代码块中，创建单例对象
		instance = new Singleton();
	}
	
	//3. 提供一个公有的静态方法，返回实例对象
	public static Singleton getInstance() {
		return instance;
	}
	
}
```
 #### 优缺：

 ### <font color=#4CAF50 size=4>3、 懒汉式(线程不安全) </font>
 #### 步骤：
不同饿汉式：在第一次使用该单例类才实例类。
 #### 代码：
```java
class Singleton {
	private static Singleton instance;
	
	private Singleton() {}
	
	//提供一个静态的公有方法，当使用到该方法时，才去创建 instance
	//即懒汉式
	public static Singleton getInstance() {
		if(instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
}
```
 #### 优缺：

 ### <font color=#4CAF50 size=4>4、 懒汉式(线程安全，同步方法) </font>
 #### 步骤：
在方式3的基础上，设置线程同步
 #### 代码：
```java
// 懒汉式(线程安全，同步方法)
class Singleton {
	private static Singleton instance;
	
	private Singleton() {}
	
	//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题
	//即懒汉式
	public static synchronized Singleton getInstance() {
		if(instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
}
```
 #### 优缺：

 ### <font color=#4CAF50 size=4>5、 懒汉式(线程安全，同步代码块) </font>
 #### 步骤：
 #### 代码：
![image.png](https://i.loli.net/2020/02/13/LaGJMR2n6Y98Qtw.png)
 #### 优缺：

 ### <font color=#4CAF50 size=4>6、 双重检查 </font>
 #### 步骤：
结合方式4和方式5。
 #### 代码：
```java
// 懒汉式(线程安全，同步方法)
class Singleton {
	private static volatile Singleton instance;
	
	private Singleton() {}
	
	//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题
	//同时保证了效率, 推荐使用
	
	public static synchronized Singleton getInstance() {
		if(instance == null) {
			synchronized (Singleton.class) {
				if(instance == null) {
					instance = new Singleton();
				}
			}
			
		}
		return instance;
	}
}
```
 #### 优缺：

 ### <font color=#4CAF50 size=4>7、 静态内部类 </font>
 #### 步骤：
 #### 代码：
```java
// 静态内部类完成， 推荐使用
class Singleton {
	private static volatile Singleton instance;
	
	//构造器私有化
	private Singleton() {}
	
	//写一个静态内部类,该类中有一个静态属性 Singleton
	private static class SingletonInstance {
		private static final Singleton INSTANCE = new Singleton(); 
	}
	
	//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE
	
	public static synchronized Singleton getInstance() {
		
		return SingletonInstance.INSTANCE;
	}
}
```
 #### 优缺：

 ### <font color=#4CAF50 size=4>8、 枚举  </font>
#### 步骤：

 #### 代码：
```java
// 懒汉式(线程安全，同步方法)
class Singleton {
	private static volatile Singleton instance;
	
	private Singleton() {}
	
	//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题
	//同时保证了效率, 推荐使用
	
	public static synchronized Singleton getInstance() {
		if(instance == null) {
			synchronized (Singleton.class) {
				if(instance == null) {
					instance = new Singleton();
				}
			}
			
		}
		return instance;
	}
}
```
 #### 优缺：

 ### <font color=#4CAF50 size=4>7、 静态内部类 </font>
 #### 步骤：
 #### 代码：
```java
// 静态内部类完成， 推荐使用
class Singleton {
	private static volatile Singleton instance;
	
	//构造器私有化
	private Singleton() {}
	
	//写一个静态内部类,该类中有一个静态属性 Singleton
	private static class SingletonInstance {
		private static final Singleton INSTANCE = new Singleton(); 
	}
	
	//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE
	
	public static synchronized Singleton getInstance() {
		
		return SingletonInstance.INSTANCE;
	}
}
```
 #### 优缺：

