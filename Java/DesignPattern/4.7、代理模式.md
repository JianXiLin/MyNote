# 代理模式

## 一、功能



## 二、实现

要求：Adaptee类适配Base类（将Adaptee的方法实现添加到Base中）




```puml
    skinparam backgroundColor Beige

    class Base{
        void a()
    }
```

### 1. 聚合(接口)方式

```puml
    skinparam backgroundColor Beige

    class Base{
        void a()
    }
    note left : 原类
    
    interface IBase{
    }
    note left : 代理接口
    
    class Proxy{
        Base base
        void a()
    }
    note right : 代理类

    note bottom of Proxy
        void a(){
            // ....代理内容
            base.a();
        }
    end note
    
    Base ..|> IBase :实现
    Proxy ..|> IBase : 实现
    Base --o Proxy : 聚合
    main -- Proxy
```

#### 缺点

- 被代理类需要实现相应的代理接口

### 2. 继承方式

```puml
    skinparam backgroundColor Beige

    class Base{
        void a()
    }
    note left : 原类
      
    class Proxy{
        void a()
    }
    note right : 代理类

    note bottom of Proxy
        void a(){
            // ....代理内容
            super.a();
        }
    end note
    
    Proxy --|> Base :继承
    main -- Proxy
```

#### 缺点

- 每个被代理类，都需手动编辑对应的代理类

### 3. 反射方式

利用Java中反射来实现，通过反射动态获取类信息，添加代理内容，然后创建新的类，作为其对应的代理类。

Java中已有的代理实现：Proxy类

```java
/**
* Proxy类中的获取代理类的方法
* var0 : 类加载器
* var1 ：被代理类的接口
* var2 ：代理处理器（该处理器中的invoke()负责执行代理内容）
*        代理类处理方法时，会调用该invoke()方法
*/
public static Object newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2) {
    ....
}
```

eg:
```java

IBase base = new Base();
Base proxyBase = (IVehical)Proxy.newProxyInstance(
        base.getClass().getClassLoader(), 
        Base.class.getInterfaces(), 
        new BaseInvacationHandler(base)
);
```

#### 4. 缺点

- 被代理的类必须实现一个及以上的接口（业务接口）

### Cglib代理

## 三、案例

