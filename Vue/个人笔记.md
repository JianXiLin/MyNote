# 个人笔记

## 1. 条件与列表

### 1.1. v-if渲染

```html
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>
```

> template元素不会保留,其在数据渲染后,则不存在
> 即 < template v-if='true'>abc < /template > 只显示abc

### 1.2. v-for列表渲染

```html
<div v-for="(item, index) in items" v-bind:key="item.id">
  {item}-{index}
</div>
<div v-for="(value, name, index) in Object" v-bind:key="item.id">
  {value}-{name}-{index}
</div>
```

> 注意：
> 1.filter()、concat()、slice()是不修改原数组，故改值时，> &emsp;需赋值给原数组
> 2.Vue不会检测数组的变化，例如依据下标该值、修改数组长度
>&emsp;可用splice(开始，数量，替换值)
>

## 2. Class、Style绑定

🔹 class

v-bind:class = 对象 | 数组 | 数组+对象

```html
//对象
<div v-bind:class="classobj"> </div>
//数组
<div v-bind:class="[isdiv1?div1:'',div2]"> </div>
//数组+对象
<div v-bind:class="[{div1:true},div2]"> </div>

<script>
    var app = new Vue({
        el: "app",
        data:{
            isdiv1:true,
            classobj:{
                div1:isdiv1,
                div2:false
            }
        }
    })
</script>
```

🔹 Style

同Class绑定

## 3. 事件

v-on: 事件名称 = val （@事件名称 =val）

```html
<input type="button" value="按钮" v-on:click="show">
 ==
<input type="button" value="按钮" @click="show">
```

### 3.1. 修饰符

🔹.stop : 阻止冒泡
🔹.prevent : 阻止默认行为 （eg: 阻止a 标签跳转）
🔹.capture : 实现捕获触发事件的机制

 ```html
  <!-- div 通过capture也会触发事件-->
<div class="inner" @click.capture="div1Handler">
    <input type="button" value="戳他" @click.stop="btnHandler">
</div>
 ```

🔹 .self
.self 只会阻止自己身上冒泡行为的触发，并不会真正阻止冒泡的行为

```html
   <!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 
	只有点击div本身才会触发 -->
    <div class="inner" @click.self="div1Handler">
      <input type="button" value="戳他" @click="btnHandler">
    </div>
```

🔹 .one

```html
    <!-- 使用 .once 只触发一次事件处理函数 
	只阻止了一次事件触发-->
    <a href="http://www.baidu.com" @click.prevent.once="linkClick">有问题，先去百度</a>
```

## 4. 计算属性、监听器

### 4.1. 计算属性

计算属性与method相比：计算属性存在缓存
method每次调用都会执行依次，计算属性则在值相同时，直接返回缓存内的结果。

```html
<script>
    var vm = new Vue({
        el: '#example',
        data: {
            message: 'Hello'
        },
        computed:{
            string1:function(){
                return this.message+'1';
            },
            string2:function(){
                get(){
                    return this.message+'2';
                },
                set(){
                    //message改变时触发
                }
            }
        }
    })
</script>
```

### 4.2. 监听器

监听器与计算属性的对比：
两者都能实现对针对数据的改变做修改，但监听器开销较大，更使用于监听某属性来做相应的开销大的操作，比较异步请求。

```html
<script>
    var vm = new Vue({
        el: '#example',
        data: {
            message: 'Hello'
        },
        watch: {
            message:{
                //当message值改变，执行
            }
        }
    })
</script>
```

## 5. 表单绑定

使用v-model进行表单内容与data数据的双向绑定。通过{{参数名}}显示数据。

### 5.1. v-model

v-model使用于标签内。将标签内的某个属性的值与data数据进行绑定。
在表单标签中可直接使用v-model="参数名"。其默认绑定的属性如下：

- text、textarea：value
- checkout、radio：checked
- select：value

🔹 注意点
v-model默认绑定一个相应的属性，例如textarea绑定value属性值。但在对改属性进行绑定则会报错，例如textarea使用v-model 和 :value会报错。

```html
<form action="#">
    <textarea name="textarea" id="demo" cols="30" rows="10"
                v-model="text_model"></textarea>
    <textarea name="textarea" id="demo1" cols="30" rows="10"
                :value="text_value"></textarea>
    <!--v-model + :value 报错-->
    <textarea name="textarea" id="demo2" cols="30" rows="10"
                v-model="text_model" :value="text_value"></textarea>
    <!-- 同样会报错 -->
    <input type="text" v-model="text_model" :value="text_value">
</form>
```

### 5.2. \{{ 参数名 }}

将显示内容与data数据进行绑定。可用于表单中内容的显示

> \<textarea>{{text}}\</textarea>) 并不会生效
显示数据使用v-model即可，v-model数据则为textarea默认显示的文本内容

### 5.3. 修饰符

🔹 .lazy
将数据同步，从input事件触发延迟到change事件触发。

```html
    <input type="text" v-model.lazy="text_model">
    <!-- 不添加lazy，在input表单写入内容时，p标签的内容就进行同步，即跟着改变 -->
    <!-- 添加lazy后，p标签的内容在change事件触发时才进行同步 -->
    <p>{{text_model}}</p>
```

🔹 .number
标记所绑定的内容为数值类型

```html
    <!-- 即使type为number，绑定的数据仍为字符串类型 -->
    <input type="number" v-model="number">
    <!-- 使用。number，绑定的数据则可为数值类型 -->
    <input type="number" v-model.number="number">
```

🔹 .trim
去除头尾空格

## 6. 组件

实现代码分模块、代码复用

### 6.1. 组件定义

```html
Vue.component('button-counter', {
    props: ['title'],
    data: function () {
        return {
            count: 0
        }
    },
  template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
})
```

> data: 在组件中应方法，不是属性
> props: 标记组件标签上哪些参数可使用,用于传值到组件内
> &emsp;&emsp;eg: \<button-counter title:"给组件的值">\</button-counter>

### 6.2. 组件触发组件外事件

1️⃣ 在组件模板中使用<b> @clike=$emit('自定义事件名',传参内容) </b> 来自定义事件（以点击事件为例）。
> 定义传参内容: 使用''则为字符串，不使用则为data内的数据。

2️⃣ 在使用组件时，使用自定义事件来触发组件外的事件。<b> @自定义事件名="外部事件名"</b>

```html
Vue.component('button-counter', {
    props: ['title'],
    data: function () {
        return {
            count: 0
        }
    },
  template: '<button @click=$emit('out')>You clicked me {{ count }} times.</button>'
})

<button-counter @:out="out_1"> </button-counter>

```

### 6.3. 插槽 slot

可理解为组件中内容的占位符，使用组件时，组件标签中间的内容则会添加到组件模板内的该占位符所在的位置。

使用: 在组件模板中使用\<slot>\</slot>

```html
Vue.component('com', {
    template: '<p> 123 <solt></solt></p>'
})
<com> 456 </com>
<!--页面上的效果同 <p> 123  456 </p>  -->

```

### 6.4. 动态组件

根据组件名称来显示相应的组件

```html
<!-- 假设组件名为com时。那其等价于<com></com> -->
<component v-bind:is="组件名称(eg:com)"></component>

```

## 7.获取html元素（少用）

1️⃣ 使用js或jquery进行获取

2️⃣ 使用vue中的<b>\$ref</b>。
&emsp;在元素中添加\$ref="name"。
&emsp;在vue实例中，通过this.$ref.name即可获取
